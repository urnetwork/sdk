//go:build ignore

/**
 * Generate TypeScript types
 */

package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"

	"github.com/urnetwork/sdk"
)

func main() {
	if err := generateTypes(); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating types: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("âœ… Generated TypeScript types successfully")
}

func generateTypes() error {
	var output strings.Builder

	output.WriteString("// Auto-generated TypeScript types from Go structs\n")
	output.WriteString("// DO NOT EDIT - Generated by: go run gen_types.go\n\n")

	// Generate types for key structs
	types := []interface{}{
		sdk.NetworkSpaceKey{},
		sdk.NetworkSpaceValues{},
		sdk.ExportNetworkSpace{},
		sdk.NetExtender{},
		sdk.NetExtenderAutoConfigure{},
		sdk.ProxyAuthResult{},
		sdk.ProxyConfigResult{},

		/**
		 * Api types
		 */
		sdk.ApiError{},
		// Auth login types
		sdk.AuthLoginWithPasswordArgs{},
		sdk.AuthLoginWithPasswordResult{},
		sdk.AuthLoginWithPasswordResultVerification{},
		sdk.AuthLoginWithPasswordResultNetwork{},
		sdk.AuthLoginArgs{},
		sdk.NetworkCheckArgs{},
		sdk.NetworkCheckResult{},
		sdk.NetworkCreateArgs{},
		sdk.NetworkCreateResult{},
		sdk.NetworkCreateResultError{},
		sdk.NetworkCreateResultVerification{},
		sdk.NetworkCreateResultNetwork{},
		sdk.WalletAuthArgs{},
		sdk.StringList{},
		sdk.AuthLoginResultError{},
		sdk.AuthLoginResultNetwork{},
		sdk.AuthVerifyArgs{},
		sdk.AuthVerifyResult{},
		sdk.AuthVerifyResultNetwork{},
	}

	for _, t := range types {
		ts, err := generateTypeScriptInterface(t)
		if err != nil {
			return err
		}
		output.WriteString(ts)
		output.WriteString("\n\n")
	}

	// Write to sdk-js/src/generated-types.ts
	outputPath := "../sdk-js/src/generated/types.ts"
	os.MkdirAll("../sdk-js/src/generated", 0755)
	return os.WriteFile(outputPath, []byte(output.String()), 0644)
}

func generateTypeScriptInterface(v interface{}) (string, error) {
	t := reflect.TypeOf(v)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("export interface %s {\n", t.Name()))

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)

		// Skip unexported fields
		if !field.IsExported() {
			continue
		}

		// Get JSON tag
		jsonTag := field.Tag.Get("json")
		if jsonTag == "-" {
			continue
		}

		jsonName, optional := parseJSONTag(jsonTag)
		if jsonName == "" {
			jsonName = toSnakeCase(field.Name)
		}

		// Map Go type to TypeScript type
		tsType := goTypeToTypeScript(field.Type)

		optionalMarker := ""
		if optional {
			optionalMarker = "?"
		}

		sb.WriteString(fmt.Sprintf("  %s%s: %s;\n", jsonName, optionalMarker, tsType))
	}

	sb.WriteString("}")
	return sb.String(), nil
}

func parseJSONTag(tag string) (name string, optional bool) {
	if tag == "" {
		return "", false
	}

	parts := strings.Split(tag, ",")
	name = parts[0]

	for _, part := range parts[1:] {
		if part == "omitempty" {
			optional = true
		}
	}

	return name, optional
}

func goTypeToTypeScript(t reflect.Type) string {
	// Handle pointers
	if t.Kind() == reflect.Ptr {
		return goTypeToTypeScript(t.Elem()) + " | null"
	}

	// Handle basic types
	switch t.Kind() {
	case reflect.String:
		return "string"
	case reflect.Bool:
		return "boolean"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
		reflect.Float32, reflect.Float64:
		return "number"
	case reflect.Slice:
		elemType := goTypeToTypeScript(t.Elem())
		return elemType + "[]"
	case reflect.Map:
		keyType := goTypeToTypeScript(t.Key())
		valueType := goTypeToTypeScript(t.Elem())
		return fmt.Sprintf("Record<%s, %s>", keyType, valueType)
	case reflect.Struct:
		// Check for known types
		switch t.String() {
		case "time.Time":
			return "string" // ISO 8601 format
		case "netip.Addr":
			return "string"
		default:
			return t.Name()
		}
	}

	return "any"
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}
